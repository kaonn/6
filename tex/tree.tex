\newcommand{\leaf}{\ensuremath{\mathtt{leaf}}}
\newcommand{\single}[1]{\ensuremath{\mathtt{single}(#1)}}
\newcommand{\ttwo}[2]{\ensuremath{\mathtt{t2}(#1,#2)}}
\newcommand{\tthree}[3]{\ensuremath{\mathtt{t3}(#1,#2,#3)}}
\newcommand{\ttrec}[8]{\mathtt{23TREC}(#1)(#2 \mid #3.#4 \mid #5.#6 \mid #7.#8)}
\newcommand{\tttree}[2]{\ensuremath{\mathtt{23tree}(#1,#2)}}
\newcommand{\word}{\mathtt{word}}
\newcommand{\mw}[1]{\mathtt{mw}(#1)}
\newcommand{\wrec}[4]{\mathtt{WREC}(#1)(#2; #3.#4)}
\newcommand{\join}{\mathsf{join}}
\newcommand{\cmp}{\mathsf{cmp}}
\newcommand{\ifnat}[3]{\mathsf{if}(#1;#2;#3)}
\newcommand{\const}[1]{\lam{\_}{\_}{#1}}
\newcommand{\eq}{\mathsf{eq}}
\newcommand{\macro}{@\!\!=}
\section{Trees}

Augment the language with the following values and commands:

\begin{align*}
    \mathsf{Node} \quad n &::= 
         \leaf
    \mid \single{v}
    \mid \ttwo{v_l}{v_r}
    \mid \tthree{v_l}{v_m}{v_r}\\
    \mathsf{Val} \quad v &::= \dots
    \mid \tttree{v}{w}
    \mid (\isOf{n}{\tttree{v}{w}})
    \mid \word
    \mid \mw{0} \dots \mw{2^{64}-1}\\
    \mathsf{Comp} \quad M &::= 
    \dots
    \mid \wrec{v}{M_0}{f}{M_1}\\
    &\mid \ttrec{v}{M_0}{a}{M_1}{l,r,f_l,f_r}{M_2}{l,m,r,f_l,f_m,f_r}{M_3}\\
\end{align*}

The semantics is extended with the computation rules:

\begin{mathpar}
\inferrule{
}{
  \step{\wrec{\mw{0}}{M_0}{f}{M_1}}{M_0}
}

\inferrule{
  F \triangleq \lam{d}{\_}{\bind{\mw{w}-d}{x}{\wrec{x}{M_0}{f}{M_1}}}
}{
  \step{\wrec{\mw{w}}{M_0}{f}{M_1}}{[F/f]M_1}
}

\inferrule{
}{
 \step{\ttrec{\leaf}{M_0}{a}{M_1}{l,r,f_l,f_r}{M_2}{l,m,r,f_l,f_m,f_r}{M_3}}{M_0}
}

\inferrule{
}{
 \step{\ttrec{\single{v}}{M_0}{a}{M_1}{l,r,f_l,f_r}{M_2}{l,m,r,f_l,f_m,f_r}{M_3}}{[v/a]M_1}
}

\inferrule{
  t = \isOf{\ttwo{l}{r}}{\tttree{s}{d}}\\
  \eval{d > \mw{0}}{\suc{\zero}}\\
  \eval{s > \mw{0}}{\suc{\zero}}\\
  v_l = \isOf{l}{\tttree{S_l}{D_l}}\\
  v_r = \isOf{r}{\tttree{S_r}{D_r}}\\
  \eval{d_l+1}{d}\\
  \eval{d_r+1}{d}\\
  \eval{s_l+s_r}{s}\\\\
  F_l \triangleq \thunk{\ttrec{v_l}{M_0}{a}{M_1}{l,r,f_l,f_r}{M_2}{l,m,r,f_l,f_m,f_r}{M_3}}\\
  F_r \triangleq \thunk{\ttrec{v_r}{M_0}{a}{M_1}{l,r,f_l,f_r}{M_2}{l,m,r,f_l,f_m,f_r}{M_3}}\\
}{
  \ttrec{t}{M_0}{a}{M_1}{l,r,f_l,f_r}{M_2}{l,m,r,f_l,f_m,f_r}{M_3} \mapsto
  \ret{\thunk{[v_l/l,v_r/r,F_l/f_l,F_r/f_r]M_2}}
}

\inferrule{
  t = \isOf{\tthree{l}{m}{r}}{\tttree{s}{d}}\\
  \eval{d > \mw{0}}{\suc{\zero}}\\
  \eval{s > \mw{0}}{\suc{\zero}}\\
  v_l = \isOf{l}{\tttree{S_l}{D_l}}\\
  v_m = \isOf{m}{\tttree{S_m}{D_m}}\\
  v_r = \isOf{r}{\tttree{S_r}{D_r}}\\
  \eval{d_l+1}{d}\\
  \eval{d_m+1}{d}\\
  \eval{d_r+1}{d}\\
  \eval{s_l+s_m+s_r}{s}\\\\
  F_l \triangleq \thunk{\ttrec{n_l}{M_0}{a}{M_1}{l,r,f_l,f_r}{M_2}{l,m,r,f_l,f_m,f_r}{M_3}}\\
  F_m \triangleq \thunk{\ttrec{n_m}{M_0}{a}{M_1}{l,r,f_l,f_r}{M_2}{l,m,r,f_l,f_m,f_r}{M_3}}\\
  F_r \triangleq \thunk{\ttrec{n_r}{M_0}{a}{M_1}{l,r,f_l,f_r}{M_2}{l,m,r,f_l,f_m,f_r}{M_3}}\\
}{
 \ttrec{t}{M_0}{a}{M_1}{l,r,f_l,f_r}{M_2}{l,m,r,f_l,f_m,f_r}{M_3} \mapsto\\
  \ret{\thunk{[v_l/l,v_m/m,v_r/r,F_l/f_l,F_m/f_m,F_r/f_r]M_3}}
}

\end{mathpar}

Augment the types:
\begin{itemize}
\item \isType{\tttree{s}{d}} 
  \begin{enumerate}
  \item \isType{A}
  \item \isVal{s}{\word}
  \item \isVal{d}{\word}
  \end{enumerate}

\item \isVal{\isOf{\leaf}{\tttree{\mw{0}}{\mw{0}}}}{\tttree{\mw{0}}{\mw{0}}}
\item \isVal{\isOf{\single{a}}{\tttree{\mw{1}}{\mw{1}}}}{\tttree{\mw{1}}{\mw{1}}}
  \begin{enumerate}
  \item \isVal{a}{A}
  \end{enumerate}
\item \isVal{\isOf{\ttwo{l}{r}}{\tttree{s}{d}}}{\tttree{s}{d}}
  \begin{enumerate}
  \item \isVal{l}{\tttree{s_l}{d}}
  \item \isVal{r}{\tttree{s_r}{d}}
  \item \eval{s_l+s_r}{s}, \eval{d_l+\mw{1}}{d}, \eval{d_r+\mw{1}}{d}
  \end{enumerate}

\item \isVal{\isOf{\tthree{l}{m}{r}}{\tttree{s}{d}}}{\tttree{s}{d}}
  \begin{enumerate}
  \item \isVal{l}{\tttree{s_l}{d}}
  \item \isVal{m}{\tttree{s_m}{d}}
  \item \isVal{r}{\tttree{s_r}{d}}
  \item \eval{s_l+s_m+s_r}{s}, \eval{d_l+\mw{1}}{d}, \eval{d_m+\mw{1}}{d}, \eval{d_r+\mw{1}}{d}
  \end{enumerate} 
\end{itemize}

\iffalse
\begin{lemma}(Balance)\label{lemma:depth}
  \isVal{\texttt{depth}}{\arr{\isOf{s}{\word}}{\zp}{
    \arr{\isOf{d}{\word}}{\zp}{\arr{\tttree{s}{d}}{\constp{2}}{\word}{\zp}}{\zp}}{\zp}}
\end{lemma}

\begin{proof}
  By 3 applications of Lemma~\ref{lemma:abs} and Lemma~\ref{lemma:ret}, 
  it suffices to show that 
  \gammaToComp{\cdot}{\mathsf{to\_nat}\;d}
  {\ttrec{t}{\ret{0}}{\_}{\ret{0}}{dl}{dl+1}{dl}{dl+1}}{\word}{\zp}
  given \isVal{s}{\word}, \isVal{t}{\word}, and \isVal{t}{\tttree{s}{d}}.
  Case on $t$:
  \begin{itemize}
    \item $t = \isOf{\leaf}{\tttree{\mw{0}}{\mw{0}}}$:\\
      Then \evalCost{\ttrec{t}{\ret{0}}{\_}{\ret{0}}{dl}{dl+1}{dl}{dl+1}}{1}{\mw{0}}, 
      and \constp{2} suffices.
    \item 
  \end{itemize}
\end{proof}
\fi

\begin{verbatim}

to_nat = \d. WREC(d){zero; p.f. r <- f 1; ret(suc(r))}

if(v;M_t;M_f) @= rec(v){M_f; _,_.M_t}

size := (\t. tmatch(t){
    s.d.ret(s)
  | s.d.a.ret(s)
  | s.d.l.r.ret(s)
  | s.d.l.m.r.ret(s)
});

depth := (\t. tmatch(t){
    s.d.ret(d)
  | s.d.a.ret(d)
  | s.d.l.r.ret(d)
  | s.d.l.m.r.ret(d)
});

T := (t2(single(0):(1,1),single(1):(1,1)):(2,2));
T1 := (t3(T,T,T):(6,3));

balance2 := (\T1. ret(\T2. tmatch(T1){
    s.d.ret(0);
  | s.d.a.ret(0);
  | s.d.l.r.
    s2 <- size T2; 
    s' <- s + s2;
    ret(t3(l,r,T2):(s',d));
  | s.d.l.m.r.
    sl <- size l; // 3
    sm <- size m; // 3
    sl' <- sl + sm; //2
    sr <- size r; //3
    s2 <- size T2; //3
    sr' <- sr + s2; //2
    d' <- d + 1; //2
    s' <- sl' + sr'; //a 2
    ret(t2(t2(l,m):(sl',d), t2(r,T2):(sr',d)):(s',d'));
}));

balance3 := (\T1. ret(\T2. ret(\T3.
  tmatch(T1){
    s.d.ret(0);
  | s.d.a.ret(0);
  | s.d.l.r.
    s2 <- size T2;
    s3 <- size T3;
    s23 <- s2 + s3;
    s' <- s + s23;
    d' <- d + 1;
    ret(t2(t2(l,r):(s,d),t2(T2,T3):(s23,d)):(s',d'));
  | s.d.l.m.r.
    sl <- size l; // 3
    sm <- size m; // 3
    sl' <- sl + sm; // 2
    sr <- size r; // 3
    s2 <- size T2; // 3
    s3 <- size T3; // 3
    s23 <- s2 + s3; // 2
    d' <- d + 1; // 2
    s' <- s + s23; // 2
    ret(t2(t3(l,m,r):(s,d), t2(T2,T3):(s23,d)):(s',d'));
})));

insertleft := (\x.ret(\t. 
  trec(t){
     ret(thunk(ret(single(x):(1,1))));
   | a.ret(thunk(ret(t2(single(x):(1,1), single(a):(1,1)):(2,2))));
   | l.r.fl.fr.
      ret(thunk(
        seq(fl; Fl.
        d <- depth Fl;
        dl <- depth l;
        b <- d > dl;
        if(b)
        then{
          balance2 Fl r
          }
        else{
          sl <- size Fl;
          sr <- size r;
          s' <- sl + sr;
          d' <- dl + 1;
          ret(t2(Fl,r):(s',d'));
          };)
      ));

   | l.m.r.fl.fm.fr. 
      ret(thunk(
        seq(fl; Fl. 
        d <- depth Fl;
        dl <- depth l;
        b <- d > dl;
        if(b) 
        then{
          balance3 Fl m r
          }
        else{
          sl <- size Fl;
          sm <- size m;
          sr <- size r;
          s' <- sl + sm;
          s'' <- s' + sr;
          d' <- dl + 1;
          ret(t3(Fl,m,r):(s'',d'));
          };)
      ));
  };
));

// 6 defs
T' <- insertleft 5 T1;
seq(T'; t'.ret(t'));
\end{verbatim}

\iffalse
full_left = \t.n. 
  23TREC(t){
    leaf => ret(zero);
    single a => ret(zero);
    t2(l,r,sl,sr,dl,dr,fl,fr) => 
      d <- dl + 1;
      b <- n == d;
      if(b; ret(zero); ret(fl));
    t3(l,m,r,sl,sm,sr,dl,dm,dr,fl,fm,fr) => 
      d <- dl + 1;
      b <- n == d;
      if(b; ret(suc(zero)); ret(fl));
  }


mk2 = \a.b. 
  case a of
    | inl l =>
      case b of
      | inl r =>
        d1 <- depth l;
        d2 <- depth r;
        b <- d1 < d2;
        if(b;
          23TREC(r){
            leaf => ret(!);
            single a => ret(inl(single(a)));
            t2(rl,rr,_,_) => ret(inl(t3(l,rl,rr)));
            t3(rl,rm,rr) => ret(inl(t2(t2(l,rl),t2(rm,rr))));
          };
          b <- d1 > d2;
          if(b;
            23TREC(l){
              leaf => ret(!);
              single a => ret(inl(single(a)));
              t2(ll,lr,_,_) => ret(inl(t3(ll,lr,r)));
              t3(ll,lm,lr) => ret(inl(t2(t2(ll,lm),t2(lr,r))));
            };
            ret(inl(t2(l,r)))
          )
        )
      | inr (r1,r2) => 
        d1 <- depth l;
        d2 <- depth r1;
        b <- d1 < d2;
        if(b;
          23TREC(r1){
            leaf => ret(!);
            single a => ret(inl(t2(r1,r2)));
            t2(r1l,r1r,_,_) => ret(inl(t2(t3(l,r1l,r1r),r2)));
            t3(r1l,r1m,r1r) => ret(inl(t3(t2(l,r1l),t2(r1m,r1r),r2)));
          };
          b <- d1 > d2;
          if(b;
            23TREC(l){
              leaf => ret(!);
              single a => ret(inl(single(a)));
              t2(ll,lr,_,_) => ret(inl(t2(l,t2(r1,r2))));
              t3(ll,lm,lr) => ret(inl(t2(t3(ll,lm,lr),t2(r1,r2))));
            };
            ret(inl(t3(l,r1,r2)))
          )
        )
    | inr (l1,l2) => 
      case b of
      | inl r =>
        d1 <- depth l1;
        d2 <- depth r;
        b <- d1 < d2;
        if(b;
          ret(inl(t2(t2(l1,l2),r)));
          b <- d1 > d2;
          if(b;
            23TREC(l2){
              leaf => ret(!);
              single a => ret(inl(t2(l1,single(a))));
              t2(rl,rr,_,_) => ret(inl(t2(l1,t3(rl,rr,r))));
              t3(rl,rm,rr) => ret(inl(t3(l,t2(rl,rm), t2(rr,r))));
            };
            ret(inl(t3(l1,l2,r)))
          )
        )
      | inr(r1,r2) => 
        d1 <- depth l1;
        d2 <- depth r1;
        b <- d1 < d2;
        if(b;
          ret(inl(t3(t2(l1,l2),r1,r2)));
          b <- d1 > d2;
          if(b;
            ret(inl(t3(l1,l2,t2(r1,r2))));
            ret(inl(t2(t2(l1,l2),t2(r1,r2))));
          )
        )

join' = \tr1.
  23TREC(tr1){
    leaf => \tr2. ret(inl(tr2));
    single a => \tr2.
      23TREC(tr2){
        leaf => ret(inl(tr1));
        single b => ret(inr(single a, single b));
        t2(l,r,fl,fr) => mk2(fl,r);
        t3(l,m,r,fl,fm,fr) => mk3(fl,m,r);
      }
    t2(l,r,fl,fr) => \tr2.
      d1 <- depth tr1;
      d2 <- depth tr2;
      b <- d1 < d2;
      if(b;
        23TREC(tr2){
         leaf => ret(!);
         single a => ret(!);
         t2(l,r,gl,gr) => mk2(gl,r);
         t3(l,m,r,gl,gm,gr) => mk3(gl,m,r);
        };
        b <- d1 > d2;
        if(b;
          r' <- fr tr2;
          mk2(l,r');;
          mk2(tr1,tr2)
        )
      )
    t3(l,m,r,fl,fm,fr) => \tr2.
      d1 <- depth tr1;
      d2 <- depth tr2;
      b <- d1 < d2;
      if(b;
        23TREC(tr2){
         leaf => ret(!);
         single a => ret(!);
         t2(l,r,gl,gr) => mk2(gl,r);
         t3(l,m,r,gl,gm,gr) => mk3(gl,m,r);
        };
        b <- d1 > d2;
        if(b;
          r' <- fr tr2;
          mk3(l,m,r');;
          mk2(tr1,tr2)
        )
      )
  }
\fi

\iffalse
  \left
  \mathsf{full\_left} \triangleq 
    \lam{t}{\_}{
      \lam{n}{\_}{
      \ttrec{t}{\const{\zero}}{\_}{\const{\zero}}
        {\_,\_,s_l,d_l,\_,\_,f_l,\_}\\{
          \bind{d_l+1}{d}{\bind{\eq\;n\;d}{b}{\ifnat{b}{\ret{b}}{\ret{f_l}}}}}\\
        {\_,\_,\_,s_l,d_l,\_,\_,\_,\_,f_l,\_,\_}{
          \bind{d_l+1}{d}{\bind{\eq\;n\;d}{b}{\ifnat{b}{\ret{\zero}}{\ret{f_l}}}}}
        }
        }\\
  \mathsf{full\_right} \triangleq 
    \lam{t}{}{
      \ttrec{t}{\const{\zero}}{\_}{\const{\zero}}
        {\_}{\lam{n}{\_}{\eq\;n\;d}}
          {\_,\_,f_l,f_r}{\bind{n-1}{n'}{f_r\; n'}}
        }\\
\join \triangleq 
  \lam{t_1}{\tttree{s_1}{d_1}}{
    \lam{t_2}{\tttree{s_2}{d_2}}{
    }}
\fi
