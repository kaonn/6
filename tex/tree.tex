\newcommand{\leaf}{\ensuremath{\mathtt{leaf}}}
\newcommand{\single}[1]{\ensuremath{\mathtt{single}(#1)}}
\newcommand{\ttwo}[2]{\ensuremath{\mathtt{t2}(#1,#2)}}
\newcommand{\tthree}[3]{\ensuremath{\mathtt{t3}(#1,#2,#3)}}
\newcommand{\ttrec}[8]{\mathtt{23TREC}(#1)(#2 \mid #3.#4 \mid #5.#6 \mid #7.#8)}
\newcommand{\tttree}[3]{\ensuremath{\mathtt{23tree}(#1,#2,#3)}}
\newcommand{\word}{\mathtt{word}}
\newcommand{\mw}[1]{\mathtt{mw}(#1)}
\newcommand{\join}{\mathsf{join}}
\newcommand{\cmp}{\mathsf{cmp}}
\newcommand{\ifnat}[3]{\mathsf{if}(#1;#2;#3)}
\newcommand{\const}[1]{\lam{\_}{\_}{#1}}
\newcommand{\eq}{\mathsf{eq}}
\newcommand{\macro}{@\!\!=}
\section{Trees}

Augment the language with the following values and commands:

\begin{align*}
    \mathsf{Node} \quad n &::= 
         \leaf
    \mid \single{v}
    \mid \ttwo{v_l}{v_r}
    \mid \tthree{v_l}{v_m}{v_r}\\
    \mathsf{Val} \quad v &::= \dots
    \mid \tttree{A}{v}{w}
    \mid (\isOf{n}{\tttree{A}{v}{w}})
    \mid \word
    \mid \mw{0} \dots \mw{2^{64}-1}\\
    \mathsf{Comp} \quad M &::= 
    \dots
    \mid \ttrec{v}{M_0}{a}{M_1}{l,r,s_l,s_r,d_l,d_r,f_l,f_r}{M_2}{l,m,r,s_l,s_m,s_r,d_l,d_m,d_r,f_l,f_m,f_r}{M_3}\\
\end{align*}

The semantics is extended with the computation rules:

\begin{mathpar}
\inferrule{
}{
 \step{\ttrec{\leaf}{M_0}{a}{M_1}{l,r,f_l,f_r}{M_2}{l,m,r,f_l,f_m,f_r}{M_3}}{M_0}
}

\inferrule{
}{
 \step{\ttrec{\single{v}}{M_0}{a}{M_1}{l,r,f_l,f_r}{M_2}{l,m,r,f_l,f_m,f_r}{M_3}}{[v/a]M_1}
}

\inferrule{
  t = \isOf{\ttwo{l}{r}}{\tttree{A}{s}{d}}\\
  \step{d > \mw{0}}{\suc{\zero}}\\
  \step{s > \mw{0}}{\suc{\zero}}\\
  v_l = \isOf{l}{\tttree{A}{S_l}{D_l}}\\
  v_r = \isOf{r}{\tttree{A}{S_r}{D_r}}\\
  \eval{d_l+1}{d}\\
  \eval{d_r+1}{d}\\
  \eval{s_l+s_r}{s}\\\\
  F_l \triangleq \thunk{\ttrec{v_l}{M_0}{a}{M_1}{l,r,f_l,f_r}{M_2}{l,m,r,f_l,f_m,f_r}{M_3}}\\
  F_r \triangleq \thunk{\ttrec{v_r}{M_0}{a}{M_1}{l,r,f_l,f_r}{M_2}{l,m,r,f_l,f_m,f_r}{M_3}}\\
}{
  \ttrec{t}{M_0}{a}{M_1}{l,r,s_l,s_r,d_l,d_r,f_l,f_r}{M_2}{l,m,r,s_l,s_m,s_r,
  d_l,d_m,d_r,f_l,f_m,f_r}{M_3} \mapsto\\
  [n_l/l,n_r/r,S_l/s_l,S_r/s_r,D_l/d_l,D_r/d_r,F_l/f_l,F_r/f_r]M_2
}

\inferrule{
  t = \isOf{\ttwo{l}{r}}{\tttree{A}{s}{d}}\\
  \step{d > \mw{0}}{\suc{\zero}}\\
  \step{s > \mw{0}}{\suc{\zero}}\\
  v_l = \isOf{l}{\tttree{A}{S_l}{D_l}}\\
  v_m = \isOf{m}{\tttree{A}{S_m}{D_m}}\\
  v_r = \isOf{r}{\tttree{A}{S_r}{D_r}}\\
  \eval{d_l+1}{d}\\
  \eval{d_m+1}{d}\\
  \eval{d_r+1}{d}\\
  \eval{s_l+s_m+s_r}{s}\\\\
  F_l \triangleq \ttrec{n_l}{M_0}{a}{M_1}{l,r,f_l,f_r}{M_2}{l,m,r,f_l,f_m,f_r}{M_3}\\
  F_m \triangleq \ttrec{n_m}{M_0}{a}{M_1}{l,r,f_l,f_r}{M_2}{l,m,r,f_l,f_m,f_r}{M_3}\\
  F_r \triangleq \ttrec{n_r}{M_0}{a}{M_1}{l,r,f_l,f_r}{M_2}{l,m,r,f_l,f_m,f_r}{M_3}\\
}{
 \ttrec{\tthree{v_l}{v_m}{v_r}}{M_0}{a}{M_1}{l,r,f_l,f_r}{M_2}{l,m,r,f_l,f_m,f_r}{M_3} \mapsto\\
 \lsub{F_l}{f_l}{\lsub{F_m}{f_m}{\lsub{F_r}{f_r}{[n_l/l,n_r/r,S_l/s_l,S_m/s_m,S_r/s_r,D_l/d_l,D_m/d_m,D_r/d_r]M_2}}}
}

\end{mathpar}

Augment the types:
\begin{itemize}
\item \isType{\tttree{A}{s}{d}} 
  \begin{enumerate}
  \item \isType{A}
  \item \isVal{s}{\word}
  \item \isVal{d}{\word}
  \end{enumerate}

\item \isVal{\leaf}{\tttree{A}{\mw{0}}{\mw{0}}}
\item \isVal{\single{a}}{\tttree{A}{\mw{1}}{\mw{1}}}
  \begin{enumerate}
  \item \isVal{a}{A}
  \end{enumerate}
\item \isVal{\ttwo{l}{r}}{\tttree{A}{s_l+s_r}{d+\mw{1}}}
  \begin{enumerate}
  \item \isVal{l}{\tttree{A}{s_l}{d}}
  \item \isVal{r}{\tttree{A}{s_r}{d}}
  \end{enumerate}

\item \isVal{\tthree{l}{m}{r}}{\tttree{A}{s_l+s_m+s_r}{d+\mw{1}}}
  \begin{enumerate}
  \item \isVal{l}{\tttree{A}{s_l}{d}}
  \item \isVal{m}{\tttree{A}{s_m}{d}}
  \item \isVal{r}{\tttree{A}{s_r}{d}}
  \end{enumerate} 

\begin{lemma}(Depth)\label{lemma:depth}
  \isVal{\texttt{depth}}{\arr{\isOf{s}{\word}}{\zp}{
    \arr{\isOf{d}{\word}}{\zp}{\arr{\tttree{A}{s}{d}}{\mathsf{to\_nat}\;d}{\word}{\zp}}{\zp}}{\zp}}
\end{lemma}
\begin{verbatim}

to_nat = \d. WORDREC(d){zero; p.f. r <- f 1; ret(suc(r))}

if(v;M_t;M_f) @= rec(v){M_f; _,_.M_t}

depth = \t. 23TREC(t){
    leaf => ret(0);
    single a => ret(1);
    t2(...,dl,...) => dl + 1;
    t3(...,dl,...) => dl + 1;
  }

balance2 = \tr1.tr2.
  23TREC(tr1){
    leaf => ret(!);
    single a => ret(t2(single(a),tr2));
    t2(l,r,...) => ret(t3(l,r,tr2));
    t3(l,m,r...) => ret(t2(t2(l,r),t2(m,tr2)));
  }

balance3 = \tr1.tr2.tr3.
  23TREC(tr1){
    leaf => ret(!);
    single a => ret(single(a));
    t2(l,r,...) => ret(t2(t2(l,r),t2(tr2,tr3)));
    t3(l,m,r...) => ret(t2(t3(l,m,r),t2(tr2,tr3)));
  }

insert_left = \x.t. 
  23TREC(t){
    leaf => ret(thunk(single(x)));
    single(a) => ret(thunk(t2(single(x), single(a)));
    t2(l,r,sl,sr,dl,dr,fl,fr) => 
      ret(thunk(
        Fl <- fl; 
        d <- depth Fl;
        b <- d > dl;
        if(b; 
          balance2 Fl r;
          t2(Fl,r)
        )
      ));

    t3(l,m,r,sl,sm,sr,dl,dm,dr,fl,fm,fr) => 
      ret(thunk(
        Fl <- fl; 
        d <- depth Fl;
        b <- d > dl;
        if(b; 
          balance3 Fl m r;
          t3(Fl,m,r)
        )
      ));
  }

full_left = \t.n. 
  23TREC(t){
    leaf => ret(zero);
    single a => ret(zero);
    t2(l,r,sl,sr,dl,dr,fl,fr) => 
      d <- dl + 1;
      b <- n == d;
      if(b; ret(zero); ret(fl));
    t3(l,m,r,sl,sm,sr,dl,dm,dr,fl,fm,fr) => 
      d <- dl + 1;
      b <- n == d;
      if(b; ret(suc(zero)); ret(fl));
  }


mk2 = \a.b. 
  case a of
    | inl l =>
      case b of
      | inl r =>
        d1 <- depth l;
        d2 <- depth r;
        b <- d1 < d2;
        if(b;
          23TREC(r){
            leaf => ret(!);
            single a => ret(inl(single(a)));
            t2(rl,rr,_,_) => ret(inl(t3(l,rl,rr)));
            t3(rl,rm,rr) => ret(inl(t2(t2(l,rl),t2(rm,rr))));
          };
          b <- d1 > d2;
          if(b;
            23TREC(l){
              leaf => ret(!);
              single a => ret(inl(single(a)));
              t2(ll,lr,_,_) => ret(inl(t3(ll,lr,r)));
              t3(ll,lm,lr) => ret(inl(t2(t2(ll,lm),t2(lr,r))));
            };
            ret(inl(t2(l,r)))
          )
        )
      | inr (r1,r2) => 
        d1 <- depth l;
        d2 <- depth r1;
        b <- d1 < d2;
        if(b;
          23TREC(r1){
            leaf => ret(!);
            single a => ret(inl(t2(r1,r2)));
            t2(r1l,r1r,_,_) => ret(inl(t2(t3(l,r1l,r1r),r2)));
            t3(r1l,r1m,r1r) => ret(inl(t3(t2(l,r1l),t2(r1m,r1r),r2)));
          };
          b <- d1 > d2;
          if(b;
            23TREC(l){
              leaf => ret(!);
              single a => ret(inl(single(a)));
              t2(ll,lr,_,_) => ret(inl(t2(l,t2(r1,r2))));
              t3(ll,lm,lr) => ret(inl(t2(t3(ll,lm,lr),t2(r1,r2))));
            };
            ret(inl(t3(l,r1,r2)))
          )
        )
    | inr (l1,l2) => 
      case b of
      | inl r =>
        d1 <- depth l1;
        d2 <- depth r;
        b <- d1 < d2;
        if(b;
          ret(inl(t2(t2(l1,l2),r)));
          b <- d1 > d2;
          if(b;
            23TREC(l2){
              leaf => ret(!);
              single a => ret(inl(t2(l1,single(a))));
              t2(rl,rr,_,_) => ret(inl(t2(l1,t3(rl,rr,r))));
              t3(rl,rm,rr) => ret(inl(t3(l,t2(rl,rm), t2(rr,r))));
            };
            ret(inl(t3(l1,l2,r)))
          )
        )
      | inr(r1,r2) => 
        d1 <- depth l1;
        d2 <- depth r1;
        b <- d1 < d2;
        if(b;
          ret(inl(t3(t2(l1,l2),r1,r2)));
          b <- d1 > d2;
          if(b;
            ret(inl(t3(l1,l2,t2(r1,r2))));
            ret(inl(t2(t2(l1,l2),t2(r1,r2))));
          )
        )

join' = \tr1.
  23TREC(tr1){
    leaf => \tr2. ret(inl(tr2));
    single a => \tr2.
      23TREC(tr2){
        leaf => ret(inl(tr1));
        single b => ret(inr(single a, single b));
        t2(l,r,fl,fr) => mk2(fl,r);
        t3(l,m,r,fl,fm,fr) => mk3(fl,m,r);
      }
    t2(l,r,fl,fr) => \tr2.
      d1 <- depth tr1;
      d2 <- depth tr2;
      b <- d1 < d2;
      if(b;
        23TREC(tr2){
         leaf => ret(!);
         single a => ret(!);
         t2(l,r,gl,gr) => mk2(gl,r);
         t3(l,m,r,gl,gm,gr) => mk3(gl,m,r);
        };
        b <- d1 > d2;
        if(b;
          r' <- fr tr2;
          mk2(l,r');;
          mk2(tr1,tr2)
        )
      )
    t3(l,m,r,fl,fm,fr) => \tr2.
      d1 <- depth tr1;
      d2 <- depth tr2;
      b <- d1 < d2;
      if(b;
        23TREC(tr2){
         leaf => ret(!);
         single a => ret(!);
         t2(l,r,gl,gr) => mk2(gl,r);
         t3(l,m,r,gl,gm,gr) => mk3(gl,m,r);
        };
        b <- d1 > d2;
        if(b;
          r' <- fr tr2;
          mk3(l,m,r');;
          mk2(tr1,tr2)
        )
      )
  }
  
\end{verbatim}

\iffalse
  \left
  \mathsf{full\_left} \triangleq 
    \lam{t}{\_}{
      \lam{n}{\_}{
      \ttrec{t}{\const{\zero}}{\_}{\const{\zero}}
        {\_,\_,s_l,d_l,\_,\_,f_l,\_}\\{
          \bind{d_l+1}{d}{\bind{\eq\;n\;d}{b}{\ifnat{b}{\ret{b}}{\ret{f_l}}}}}\\
        {\_,\_,\_,s_l,d_l,\_,\_,\_,\_,f_l,\_,\_}{
          \bind{d_l+1}{d}{\bind{\eq\;n\;d}{b}{\ifnat{b}{\ret{\zero}}{\ret{f_l}}}}}
        }
        }\\
  \mathsf{full\_right} \triangleq 
    \lam{t}{}{
      \ttrec{t}{\const{\zero}}{\_}{\const{\zero}}
        {\_}{\lam{n}{\_}{\eq\;n\;d}}
          {\_,\_,f_l,f_r}{\bind{n-1}{n'}{f_r\; n'}}
        }\\
\join \triangleq 
  \lam{t_1}{\tttree{A}{s_1}{d_1}}{
    \lam{t_2}{\tttree{A}{s_2}{d_2}}{
    }}
\fi
\end{itemize}
